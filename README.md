# leetcode-answer

## sf40days
### 链表数组
- 206.反转单链表:https://leetcode-cn.com/problems/reverse-linked-list/
- 24.两两交换链表中的节点: https://leetcode-cn.com/problems/swap-nodes-in-pairs/
- 141.判断链表是否有环: https://leetcode-cn.com/problems/linked-list-cycle/
- 142.环形链表: https://leetcode-cn.com/problems/linked-list-cycle-ii/
- 25.每k个节点一组翻转链表:
https://leetcode-cn.com/problems/reverse-nodes-in-k-group/
### 堆栈、队列
- 678.判断括号字符串是否有效 :https://leetcode-cn.com/problems/valid-parenthesis-string/
- 232.用栈实现队列:https://leetcode-cn.com/problems/implement-queue-using-stacks/
- 225.用队列实现堆栈:https://leetcode-cn.com/problems/implement-stack-using-queues/
### 优先队列
- 703.返回数据流中的第k大元素: https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/
- 239.返回滑动窗口中的最大值: https://leetcode-cn.com/problems/sliding-window-maximum/
### 映射(Map)和散列(hash)
- 1.两数之和: https://leetcode-cn.com/problems/two-sum/
- 15.三数之和: https://leetcode-cn.com/problems/3sum/
### 树(Tree)、二叉树(Binary Tree)、二叉搜索树(Binary SearchTree)和图(Graph)
- 98.验证二叉搜索树 
- 235.二叉树的最近公共祖先
- 236.二叉搜索树的最近公共祖先
### 二叉树遍历
### 递归(Recursion)和分治(Divide&Conquer)
- 50.pow(n, x): 
- 169.求众数Majority: 

### 贪心算法 Greedy
对问题求解时，总是做出在当前看来是最好的选择。
- 122.买卖股票问题 Buy/Sell stocks: https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/

### 广度优先搜索 (BFS: Breadth First Search) - 队列quene
### 深度优先搜索 (DFS: Depth First Search) - 推荐递归写法（也可以用栈stack）
- 102.二叉树层次遍历(Binary Tree Level Order): 
- xxx.二叉树的最大和最小深度
- xxx.生成有效括号组合
